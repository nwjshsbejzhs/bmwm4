<!DOCTYPE html>
<html lang="sl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Toy Sports Car Customizer - Deluje 100%</title>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #111; touch-action: none; }
        #info { position: absolute; top: 10px; left: 10px; color: white; z-index: 100; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 10px; }
    </style>
</head>
<body>
    <div id="info">
        <strong>Toy Sports Car Customizer</strong><br>
        Drži & vleci: Rotiraj | Dva prsta: Zoom<br>
        GUI levo: Spreminjaj barve karoserije/platišč!
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.167.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.167.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(4, 3, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.5;
        document.body.appendChild(renderer.domElement);

        // HDR za realne refleksije (kot pravi avto)
        new RGBELoader().load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/venice_sunset_1k.hdr', function(texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = texture;
        });

        const ambient = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0.8, 0);

        // Pravi Toy Sports Car (Khronos official - super grafika!)
        const loader = new GLTFLoader();
        loader.load('https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/ToyCar/glTF-Binary/ToyCar.glb', function(gltf) {
            const car = gltf.scene;
            car.scale.set(3, 3, 3); // malo večji za boljši pogled
            car.position.y = 0;
            scene.add(car);

            // GUI za custom barve
            const gui = new dat.GUI({ width: 300 });
            const colors = { body: '#ff0000', wheels: '#111111' };

            let bodyMesh = null;
            const wheelMeshes = [];

            car.traverse((child) => {
                if (child.isMesh) {
                    if (child.name.toLowerCase().includes('body') || child.name.toLowerCase().includes('chassis')) {
                        bodyMesh = child;
                    }
                    if (child.name.toLowerCase().includes('wheel') || child.name.toLowerCase().includes('tire')) {
                        wheelMeshes.push(child);
                    }
                }
            });

            if (bodyMesh) {
                gui.addColor(colors, 'body').name('Karoserija').onChange(v => bodyMesh.material.color.set(v));
            }
            gui.addColor(colors, 'wheels').name('Platišča').onChange(v => wheelMeshes.forEach(m => m.material.color.set(v)));

            gui.open();
        }, undefined, function(error) {
            alert('Napaka – osveži z Wi-Fi!');
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>